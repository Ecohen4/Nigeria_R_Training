basic R
========================================================

getting started
----
### interface of Rstudio

### set working directory 
```{r}
# getting the current working directory 
getwd()
```


```{r echo=TRUE, eval=FALSE}
### setting "my working directory" as "~/work/r/nigeria_r_training/"
setwd("~/work/r/nigeria_r_training/")
```

### libraries
 * install packages
 * to install packges in R, call __install.packages()__ with quoted package name: 
```{r echo=TRUE, eval=FALSE}
install.packages("plyr")
```   
  2. to load libraries in R call __library()__ fucntion
  
```{r}
library(plyr)
```
  * libraries are additional packages to R that contain additional specialized functions 
  * plyr library is used for aggregating data, which will be explored in detail later


### reading data: read.csv
  * csv is the prefered data format in NMIS and in the data science space in general. although there are functions in R to read other data formats, we recommend that one converts to csv prior to loading.  
```{r}
sample_data <- read.csv("./sample_health_facilities.csv", na.strings = "NA", 
                        stringsAsFactors=FALSE, skip=0, nrows=-1)
```
### data types: 
  1. numerical
  2. integer
  3. boolean
  4. character
  5. factors
    * generic data type used as alternative to all of the above. we recommend __not__ using.  
  6. NA
    * an additional data type in R for __value NOT AVAILABLE__, which can be found in any of the data type above

data.frames
--------------

* a data.frame is made up of: __[rows, columns]__
```{r}
dim(sample_data)
#dimensions function shows 2000 rows and 104 columns for sample_data
```

### getting names/headers of the data.frame
```{r message=FALSE, echo=TRUE, eval=FALSE}
names(sample_data)
```
```{r message=FALSE, echo=FALSE, eval=TRUE}
names(sample_data)[1:10]
```


### getting value/column from a data.frame
* a column in our data set is equavilent to a question in the survey
 1. using "$" operator
 2. calling column by it's name directly
 3. note: using head() to show only the first nth elements
```{r echo=TRUE, eval=FALSE}
sample_data$lga

sample_data[, "lga"]
```

```{r echo=FALSE, eval=TRUE}
head(sample_data$lga, 10)

head(sample_data[, "lga"], 10)
```


### getting row content by calling the row number
 * a row in our data set is equavilent to one full survey i.e. one facility
 * note: index in R starts at 1 instead of 0
```{r echo=TRUE, eval=FALSE}
sample_data[2, ]
```
```{r echo=FALSE, eval=TRUE}
sample_data[2, ][1:10]
```
### more slicing and dicing in R
* getting the element in 4th row and 5th column
```{r}
sample_data[4, 5]
```

* getting the elements from 4th to 6th row and column 1 to column 5(inclusive)
```{r}
sample_data[4:6, 1:5]
```

### exploring the data frame with some useful functions
* getting the structure
```{r echo=TRUE, eval=FALSE}
str(sample_data)
```

* getting the dimension of data.frame
```{r echo=TRUE, eval=TRUE}
dim(sample_data)
```

* getting the class of specific column
```{r}
class(sample_data$lga)

class(sample_data[, 1])

class(sample_data[, "lga"])
```

* getting the summary/descriptive statistics 
* works with both column and data.frame
```{r echo=TRUE, eval=FALSE}
summary(sample_data$zone)
summary(sample_data)
```
```{r echo=FALSE, eval=TRUE}
summary(sample_data$zone)
summary(sample_data)[1:7, 1:10]
```


* table of content of COLUMN
```{r}
table(sample_data$zone)
```

creating data frames
---------------------

### joining columns:
* R supports SQL-like join functionality with merge()
```{r, echo=FALSE}
data1 <- sample_data[,-(2:4)]
data2 <- unique(sample_data[, 2:5])
data3 <- sample_data[, 2:5]

data4 <- sample_data[1:100, ]
data5 <- sample_data[101:2000, ]
```

* inner join
```{r}
inner_join <- merge(data1, data2, by="lga_id")
```

* outer join
```{r}
outer_join <- merge(data1, data2, by="lga_id", all=TRUE)
```

* left outer join
```{r}
left_outer_join <- merge(data1, data2, by.x="lga_id",
                    by.y="lga_id",all.x=TRUE)
```

* concatenate data.frames COLUMNwise with cbind()
* note that the order of rows in original data is unchanged
```{r, echo=TRUE, eval=FALSE}
cbind(data1, data3)
```
```{r, echo=FALSE, eval=TRUE}
cbind(data1, data3)[1:10,1:10]
```


* concatenate data.frames ROWise with cbind()
* note that the order of columns in original data is unchanged
```{r, echo=TRUE, eval=FALSE}
rbind(data4, data5)
```
```{r, echo=FALSE, eval=TRUE}
rbind(data4, data5)[1:10,1:10]
```
* use with care: make sure your columns alligns before using, and here is an example of miss-use
```{r, echo=TRUE, eval=FALSE}
rbind(data1, data3)
```
```{r, echo=FALSE, eval=TRUE}
rbind(data1, data3)[1:10,1:10]
```
* rbind.fill() a powerful rbind() realization in __plyr__ package
* with rbind you have to make every column in both data.frame exists and alligns(have the same index number), but with rbind.fill you don't have to worry about it
* rbind.fill() finds the corresponding column in data.frame2 and concatenate the data, and if there's no corresponding part is assigns __*NA*__
```{r echo=TRUE, eval=FALSE}
rbind.fill(data1, data3)
```
```{r echo=FALSE, eval=TRUE}
rbind.fill(data1, data3)[1:10, 1:10]
```

### creating derivative data frames via subset:
* getting a subset of original data with handy functions saves a lot of typing
* campare the two outputs
```{r, echo=TRUE, eval=FALSE}
subset(sample_data, lga_id < 600, select=c("lga_id", "lga", "state" ))

sample_data[sample_data$lga_id < 600, c("lga_id", "lga", "state")]
```

```{r, echo=FALSE, eval=TRUE}
head(subset(sample_data, lga_id < 600, select=c("lga_id", "lga", "state" )), 10)
head(sample_data[sample_data$lga_id < 600, c("lga_id", "lga", "state")], 10)
```

data cleaning:
----

### type conversion
* type convertion can be force by __as.\*()__ function
* common __\*__ types you'd encounter are: 
  1. numeric
  2. integer
  3. character
  4. logical
* some times you'll encounter __factor__ variables, we recommand using __as.character()__ to conver it into character type before any manipulation applied

* here's some examples
```{r}
my_numbers = c("1", "2", "3", "4", "5")
my_numbers
as.numeric(my_numbers)
```

creating and deleting columns
--------------

* add columns
```{r}
sample_data$lga_id_national <- paste("9ja:", sample_data$lga_id, sep = "")
head(sample_data$lga_id_national, 5)

```

* formulas (booleans + conditions: == “” etc. etc.)
=======
### string manipulations
* we're going to cover regex suite comes with base R, string_r packages have similar implementations.
* we're not going to cover regex/ regular expression in this tuorial.
* getting position of matched pattern with grep()
```{r}
my_strings = c("Hello", "World", 'Foo')
grep(pattern="l", x=my_strings, ignore.case=FALSE)
#when value argument is set to true, grep() returns the actual strings matchs the patterns
grep(pattern="l", x=my_strings, ignore.case=FALSE, value=T)
```
* find pattern in strings and replace with sub()
* gsub() means global sub, which replace all the occurance of matching pattern, while sub() only works on the first appearance.
```{r}
my_strings
sub(pattern="o", replacement="X", x=my_strings)
gsub(pattern="o", replacement="X", x=my_strings)
```
* change to upper/lower case with toupper()/ tolower()
```{r}
my_strings
toupper(my_strings)
tolower(my_strings)
```
* concatenate strings with paste():
```{r}
paste("hello", "world", "foo", sep=",")
```
* if you're trying to concate every element in a vector/ list, use __collapse__ argument in paste()
```{r}
paste(my_strings, sep=',')
paste(my_strings, collapse=',')
```

### writing out data
* R can output multiple different output format, but we're going to cover csv and RDS format
* writing csv file with write.csv()
 * if you find output row.names everything annoying, set row.names argument to FALSE in write.csv()
```{r}
write.csv(sample_data, "./my_output.csv", row.names=FALSE)
```
* we recommend output your data as RDS file, if you're only going to reuse it in R.
* use saveRDS() to save object in workspace to your harddrive
  * no row.names argument needs to be used, since we're saving the R object into a binary file
```{r}
saveRDS(sample_data, "./my_output.RDS")
```
* use readRDS() function to load saved RDS file
```{r echo=TRUE, eval=FALSE}
readRDS("./my_output.RDS")
```
```{r echo=FALSE, eval=TRUE}
readRDS("./my_output.RDS")[1:10, 1:10]
```

Aggregations in R:
----
* there are many functions that can do aggregation for you, but we are only going to cover __ddply()__ in __plyr__ package

* creating simple aggregated summary:
* note: 
  1. __(group) by__ variable must have at least one input
  2. you __must__ specify what type of aggregation you want to perform, choose one from: summarize, transform
```{r}
library(plyr)
my_summary <- ddply(sample_data, .(state, lga), summarise, 
                    counts = length(lga_id),
                    total_num_nurse = sum(num_nurses_fulltime, na.rm=T),
                    avg_c_section = mean(c_section_yn == T,na.rm=T))
head(my_summary)
```
* look at the output and compare the difference, the only change here is replacing summarise with transform
```{r}
my_summary <- ddply(sample_data, .(state, lga), transform, 
                    counts = length(lga_id),
                    total_num_nurse = sum(num_nurses_fulltime, na.rm=T),
                    avg_c_section = mean(c_section_yn == T,na.rm=T))
dim(my_summary)
```

Advanced R
========================================================

creation of more complex columns(indicators) with __ifelse()__:
-------------------------------------


map functions: apply()
-----------------------

improvements:
-----------------
* source()
* idata.frame()




