Before started
=======

we recommend watch the following video before reading this document
* [Video tutorial for R from Google Developer](http://www.youtube.com/watch?v=iffR3fWv4xw&list=PLOU2XLYxmsIK9qQfztXeybpHvru-TrqAP)

basic R
========================================================

getting started
----
### interface of Rstudio

![alt text][R_studio]

[R_studio]: https://lh3.googleusercontent.com/-fFe1VlFiVzA/TWvS0Cuvc3I/AAAAAAAALmk/RfFLB0h5dUM/s1600/rstudio-windows.png

### set working directory 
```{r}
# getting the current working directory 
getwd()
```


```{r echo=TRUE, eval=FALSE}
### setting "my working directory" as "~/work/r/nigeria_r_training/"
setwd("~/work/r/nigeria_r_training/")
```

### libraries
 * install packages
 * to install packges in R, call __install.packages()__ with quoted package name: 
```{r echo=TRUE, eval=FALSE}
install.packages("plyr")
```   
 * to load libraries in R call __library()__ fucntion
  
```{r}
library(plyr)
```
  * libraries are additional packages to R that contain additional specialized functions 
  * plyr library is used for aggregating data, which will be explored in detail later

* be sure that the package you are trying to load is installed on your computer
```{r}
library(eaf)
```


### reading data: read.csv
  * csv is the prefered data format in NMIS and in the data science space in general. although there are functions in R to read other data formats, we recommend that one converts to csv prior to loading.  
```{r}
sample_data <- read.csv("./sample_health_facilities.csv", na.strings = "NA", 
                        stringsAsFactors=FALSE)

sample_data <- subset(sample_data, select=c("lga", "lga_id", "state", "zone", "c_section_yn", "num_nurses_fulltime", "gps", "num_lab_techs_fulltime", "management", "num_doctors_fulltime"))
```
  *stringsAsFactors will be explained later, but for now we recommend always using it
  
### data types: 
  1. numerical
  2. integer
  3. boolean
  4. character
  5. factors
    * generic data type used as alternative to all of the above. we recommend __not__ using. 
    * specifically, there are typically challenges with factor => integer/numeric conversions
    * for additional information on working with factors in your data: [More information on Factors](http://www.statmethods.net/input/datatypes.html)

  6. NA
    * an additional data type in R for value __NOT AVAILABLE__, which can be found in any of the data type above

data.frames
--------------

* a data.frame is made up of: __[rows, columns]__
```{r}
dim(sample_data)
#dimensions function shows 2000 rows and 104 columns for sample_data
```

### getting names/headers of the data.frame
```{r message=FALSE, echo=TRUE, eval=FALSE}
names(sample_data)
```
```{r message=FALSE, echo=FALSE, eval=TRUE}
names(sample_data)[1:10]
```


### getting value/column from a data.frame
* a column in our data set is equavilent to a question in the survey
 1. using "$" operator
 2. calling column by it's name directly
 3. note: using head() to show only the first nth elements
```{r echo=TRUE, eval=FALSE}
sample_data$lga

sample_data[, "lga"]
```

```{r echo=FALSE, eval=TRUE}
head(sample_data$lga, 10)

head(sample_data[, "lga"], 10)
```
* We generally prefer the first strategy, but sometimes we'll need to use the second strategy. Note that spellings have to be exact, and when using the $ notation, you can use tab completion. Try writing sample_data$l and hitting tab, for example. 

### getting row content by calling the row number
 * a row in our data set is equavilent to one full survey i.e. one facility
 * note: index in R starts at 1 instead of 0
```{r echo=TRUE, eval=FALSE}
sample_data[2, ]
```
```{r echo=FALSE, eval=TRUE}
sample_data[2, ][1:10]
```
### more slicing and dicing in R
* getting the element in 4th row and 5th column
```{r}
sample_data[4, 5]
```

* getting the elements from 4th to 6th row and column 1 to column 5(inclusive)
```{r}
sample_data[4:6, 1:5]
```

### exploring the data frame with some useful functions
* getting the structure
```{r echo=TRUE, eval=FALSE}
str(sample_data)
```

* getting the dimension of data.frame
```{r echo=TRUE, eval=TRUE}
dim(sample_data)
```

* getting the class of specific column

  * note: class is the type of things in R. In python, this is equivalent to calling type(obj). In javascript, you would use typeof

```{r}
class(sample_data$lga)

class(sample_data[, 1])

class(sample_data[, "lga"])
```

* getting the summary/descriptive statistics 

  * __table()__ should be used for character and string variables
  * __summary()__ should be used for numerical or boolean variables
```{r echo=TRUE, eval=FALSE}
table(sample_data$zone)
```
  
```{r echo=FALSE, eval=TRUE}
table(sample_data$zone)
```

```{r echo=TRUE, eval=FALSE}
summary(sample_data$num_nurses_fulltime)
```
  
```{r echo=FALSE, eval=TRUE}
summary(sample_data$num_nurses_fulltime)
```

creating data frames
---------------------

### joining columns:
* R supports SQL-like join functionality with merge()
```{r, echo=FALSE}
data1 <- subset(sample_data, select=-c(lga, state, zone))
data2 <- subset(sample_data, select=c(lga, lga_id, state, zone))


data4 <- sample_data[1:20, ]
data5 <- sample_data[20:200, ]
```

* inner join
```{r}
inner_join <- merge(data1, data2, by="lga_id")
```

* outer join
```{r}
outer_join <- merge(data1, data2, by="lga_id", all=TRUE)
```

* left outer join
```{r}
left_outer_join <- merge(data1, data2, by.x="lga_id",
                    by.y="lga_id",all.x=TRUE)
```

* concatenate data.frames COLUMNwise with cbind()
* note that the order of rows in original data is unchanged
```{r, echo=TRUE, eval=FALSE}
cbind(data1, data2)
```
```{r, echo=FALSE, eval=TRUE}
cbind(data1, data2)[1:10,1:10]
```


* concatenate data.frames ROWise with cbind()
* note that the order of columns in original data is unchanged
```{r, echo=TRUE, eval=FALSE}
rbind(data4, data5)
```
```{r, echo=FALSE, eval=TRUE}
rbind(data4, data5)[1:10,1:10]
```
* use with care: make sure your columns alligns before using, and here is an example of miss-use
```{r, echo=TRUE, eval=FALSE}
rbind(data1, data2)
```
```{r, echo=FALSE, eval=TRUE}
rbind(data1, data2)[1:10,1:10]
```
* rbind.fill() a powerful rbind() realization in __plyr__ package
* with rbind you have to make every column in both data.frame exists and alligns(have the same index number), but with rbind.fill you don't have to worry about it
* rbind.fill() finds the corresponding column in data.frame2 and concatenate the data, and if there's no corresponding part is assigns __*NA*__
```{r echo=TRUE, eval=FALSE}
rbind.fill(data1, data2)
```
```{r echo=FALSE, eval=TRUE}
rbind.fill(data1, data2)[1:10, 1:10]
```

### creating derivative data frames via subset:
* getting a subset of original data with handy functions saves a lot of typing
* campare the two outputs
```{r, echo=TRUE, eval=FALSE}
subset(sample_data, lga_id < 600, select=c("lga_id", "lga", "state" ))

sample_data[sample_data$lga_id < 600, c("lga_id", "lga", "state")]
```

```{r, echo=FALSE, eval=TRUE}
head(subset(sample_data, lga_id < 600, select=c("lga_id", "lga", "state" )), 10)
head(sample_data[sample_data$lga_id < 600, c("lga_id", "lga", "state")], 10)
```

data cleaning:
----

### type conversion
* type conversion can be forced by __as.\*()__ function
* common __\*__ types you'd encounter are: 
  1. numeric
  2. integer
  3. character
  4. logical
* sometimes you'll encounter __factor__ variables, we recommend using __as.character()__ function to convert it into character type before proceeding 

* here's some examples
```{r}
my_numbers <- c("1", "2", "3", "4", "5")
my_numbers
as.numeric(my_numbers)
```

creating and deleting columns
--------------
* column creation: simple examples
```{r}
sample_data$simple <- "who wants some egusi?"
#a summary of the newly created simple column
head(sample_data$simple)

sample_data$simple <- 1963
#a summary of the newly defined simple column
head(sample_data$simple)
```
  
* column creation: using already existing columns
```{r}
#a look at the lga column 
head(sample_data$lga_id)
#creating a new column, by pasting "9ja:" to the values of the lga column
sample_data$lga_id_national <- paste("9ja:", sample_data$lga_id, sep = "")
#a look at the the new lga_id_national column
head(sample_data$lga_id_national)
```

* column creation: boolean columns
```{r}
sample_data$public <- sample_data$management == "public"
table(sample_data$public)

sample_data$public_2_docs <- sample_data$management == "public" & sample_data$num_doctors_fulltime == 2
table(sample_data$public_2_docs) 
  
```

* column creation: sum of multiple numerical columns 
```{r}
sample_data$num_nurselabtechs_fulltime <- rowSums(cbind(sample_data$num_nurses_fulltime,
                                            sample_data$num_lab_techs_fulltime, na.rm = T))
```
  
```{r}
#now we can view all three variables: the new num_nurselabtechs_fulltime variable, and the two used to create it
head(subset(sample_data, select=c("num_nurses_fulltime", "num_lab_techs_fulltime", "num_nurselabtechs_fulltime")), 5)
```

* removing columns
```{r}
sample_data$num_nurselabtechs_fulltime <- NULL
#testing to make sure it no longer exists
summary(sample_data$num_nurselabtechs_fulltime)
```
 
* renaming		
```{r}
#quote the current variable name, and set it equal the quoted desired name  
sample_data <- rename(sample_data, c("gps" = "global_positioning_system"))
```



data cleaning
--------------
### string manipulations
* we're going to cover regex suite comes with base R, string_r packages have similar implementations.
* we're not going to cover regex/ regular expression in this tuorial.
* getting position of matched pattern with grep()
```{r}
my_strings = c("Hello", "World", 'Foo')
grep(pattern="l", x=my_strings, ignore.case=FALSE)
#when value argument is set to true, grep() returns the actual strings matchs the patterns
grep(pattern="l", x=my_strings, ignore.case=FALSE, value=T)
```
* find pattern in strings and replace with sub()
* gsub() means global sub, which replace all the occurance of matching pattern, while sub() only works on the first appearance.
```{r}
my_strings
sub(pattern="o", replacement="X", x=my_strings)
gsub(pattern="o", replacement="X", x=my_strings)
```
* change to upper/lower case with toupper()/ tolower()
```{r}
my_strings
toupper(my_strings)
tolower(my_strings)
```
* concatenate strings with paste():
```{r}
paste("hello", "world", "foo", sep=",")
```
* if you're trying to concate every element in a vector/ list, use __collapse__ argument in paste()
```{r}
paste(my_strings, sep=',')
paste(my_strings, collapse=',')
```

### writing out data
* R can output multiple different output format, but we're going to cover csv and RDS format
* writing csv file with write.csv()
 * if you find output row.names everytime annoying, set row.names argument to FALSE in write.csv()
```{r}
write.csv(sample_data, "./my_output.csv", row.names=FALSE)
```
* we recommend output your data as RDS file, if you're only going to reuse it in R.
* use saveRDS() to save object in workspace to your harddrive
  * no row.names argument needs to be used, since we're saving the R object into a binary file
```{r}
saveRDS(sample_data, "./my_output.RDS")
```
* use readRDS() function to load saved RDS file
```{r echo=TRUE, eval=FALSE}
readRDS("./my_output.RDS")
```
```{r echo=FALSE, eval=TRUE}
readRDS("./my_output.RDS")[1:10, 1:10]
```

Aggregations in R:
----
* there are many functions that can do aggregation for you, but we are only going to cover __ddply()__ in __plyr__ package

* creating simple aggregated summary:
* note: 
  1. __(group) by__ variable must have at least one input
  2. you __must__ specify what type of aggregation you want to perform, choose one from: summarize, transform
* [the link to the package dodument](http://cran.r-project.org/web/packages/plyr/plyr.pdf)
```{r}
library(plyr)
my_summary <- ddply(sample_data, .(state, lga), summarise, 
                    counts = length(lga_id),
                    total_num_nurse = sum(num_nurses_fulltime, na.rm=T),
                    avg_c_section = mean(c_section_yn == T,na.rm=T))
head(my_summary)
```
* look at the output and compare the difference, the only change here is replacing summarise with transform
```{r}
my_summary <- ddply(sample_data, .(state, lga), transform, 
                    counts = length(lga_id),
                    total_num_nurse = sum(num_nurses_fulltime, na.rm=T),
                    avg_c_section = mean(c_section_yn == T,na.rm=T))
dim(my_summary)
```

Advanced R
========================================================

creation of more complex columns(indicators) with __ifelse()__:
-------------------------------------

install packages from outside of cran
-------------------------------------
* in order to install packages on github we need some extra work
* this tutorial will use the example of formhub.R
* first step: install and load __devtools__ package from cran
```{r}
install.packages('devtools') 
library(devtools)
```
* second step: use __install_github("repo_name", "user_name")__ function to install packages on github
```{r}
install_github("formhub.R", username="SEL-Columbia")
library(formhub)
```

map functions: apply()
-----------------------
* instead of using for loops, we encourage using map. The apply/sapply is the implementation of map in R
* Here's the simply example for using apply to loop through every column and see the class of the column
  * note: __MARGIN = 2__ specifies doing column-wise process
```{r echo=TRUE, eval=FALSE}
apply(sample_data, MARGIN=2, FUN=class)
```
```{r echo=FALSE, eval=TRUE}
apply(sample_data, MARGIN=2, FUN=class)[1:10]
```

* you can also define your own function in apply()
* the following code returns sum of __NAs__ in each row
  * note: when you're define your own function in apply use semi-colon as the line marker.
  * note: __MARGIN = 1__ specifies doing row-wise process
```{r echo=TRUE, eval=FALSE}
apply(sample_data, MARGIN=1, function(x) {
  na_idx <- is.na(x);
  length(which(na_idx))
})
```
```{r echo=FALSE, eval=TRUE}
apply(sample_data, MARGIN=1, function(x) {
  na_idx <- is.na(x);
  length(which(na_idx))
  })[1:10]
```

improvements:
-----------------
* load your own functions into workspace with source()
```{r}
source("./my_source_functions.R")
my_sum(1,2)
```

* optimize ddply with idata.frame()
 * idata.frame optimizes the computation speed but at the cost of a slight more complicated code





